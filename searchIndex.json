[
{
		"title": "Command-line Environment · Missing Semester",
		"date":"Wed Jan 03 2024 05:33:18 GMT+0000 (Coordinated Universal Time)",
		"url":"/",
		"content": "In this lecture we will go through several ways in which you can improve your workflow when using the shell. We have been working with the shell for a while now, but we have mainly focused on executing different commands. We will now see how to run several processes at the same time while keeping track of them, how to stop or pause a specific process and how to make a process run in the background.\nWe will also learn about different ways to improve your shell and other tools, by defining aliases and configuring them using dotfiles. Both of these can help you save time, e.g. by using the same configurations in all your machines without having to type long commands. We will look at how to work with remote machines using SSH.\nIn some cases you will need to interrupt a job while it is executing, for instance if a command is taking too long to complete (such as a find with a very large directory structure to search through). Most of the time, you can do Ctrl-C and the command will stop. But how does this actually work and why does it sometimes fail to stop the process?\nKilling a process\nYour shell is using a UNIX communication mechanism called a signal to communicate information to the process. When a process receives a signal it stops its execution, deals with the signal and potentially changes the flow of execution based on the information that the signal delivered. For this reason, signals are software interrupts.\nIn our case, when typing Ctrl-C this prompts the shell to deliver a SIGINT signal to the process.\nHere’s a minimal example of a Python program that captures SIGINT and ignores it, no longer stopping. To kill this program we can now use the SIGQUIT signal instead, by typing Ctrl-\\.\n#!/usr/bin/env python\nimport signal, time\n\ndef handler(signum, time):\nprint(&quot;\\nI got a SIGINT, but I am not stopping&quot;)\n\nsignal.signal(signal.SIGINT, handler)\ni = 0\nwhile True:\ntime.sleep(.1)\nprint(&quot;\\r{}&quot;.format(i), end=&quot;&quot;)\ni += 1\n\nHere’s what happens if we send SIGINT twice to this program, followed by SIGQUIT. Note that ^ is how Ctrl is displayed when typed in the terminal.\n$ python sigint.py\n24^C\nI got a SIGINT, but I am not stopping\n26^C\nI got a SIGINT, but I am not stopping\n30^\\[1] 39913 quit python sigint.py\n\nWhile SIGINT and SIGQUIT are both usually associated with terminal related requests, a more generic signal for asking a process to exit gracefully is the SIGTERM signal. To send this signal we can use the kill command, with the syntax kill -TERM &lt;PID&gt;.\nPausing and backgrounding processes\nSignals can do other things beyond killing a process. For instance, SIGSTOP pauses a process. In the terminal, typing Ctrl-Z will prompt the shell to send a SIGTSTP signal, short for Terminal Stop (i.e. the terminal’s version of SIGSTOP).\nWe can then continue the paused job in the foreground or in the background using fg or bg, respectively.\nThe jobs command lists the unfinished jobs associated with the current terminal session. You can refer to those jobs using their pid (you can use pgrep to find that out). More intuitively, you can also refer to a process using the percent symbol followed by its job number (displayed by jobs). To refer to the last backgrounded job you can use the $! special parameter.\nOne more thing to know is that the &amp; suffix in a command will run the command in the background, giving you the prompt back, although it will still use the shell’s STDOUT which can be annoying (use shell redirections in that case).\nTo background an already running program you can do Ctrl-Z followed by bg. Note that backgrounded processes are still children processes of your terminal and will die if you close the terminal (this will send yet another signal, SIGHUP). To prevent that from happening you can run the program with nohup (a wrapper to ignore SIGHUP), or use disown if the process has already been started. Alternatively, you can use a terminal multiplexer as we will see in the next section.\nBelow is a sample session to showcase some of these concepts.\n$ sleep 1000{ #Z}\n\n[1] + 18653 suspended sleep 1000\n\n$ nohup sleep 2000 &amp;\n[2] 18745\nappending output to nohup.out\n\n$ jobs\n[1] + suspended sleep 1000\n[2] - running nohup sleep 2000\n\n$ bg %1\n[1] - 18653 continued sleep 1000\n\n$ jobs\n[1] - running sleep 1000\n[2] + running nohup sleep 2000\n\n$ kill -STOP %1\n[1] + 18653 suspended (signal) sleep 1000\n\n$ jobs\n[1] + suspended (signal) sleep 1000\n[2] - running nohup sleep 2000\n\n$ kill -SIGHUP %1\n[1] + 18653 hangup sleep 1000\n\n$ jobs\n[2] + running nohup sleep 2000\n\n$ kill -SIGHUP %2\n\n$ jobs\n[2] + running nohup sleep 2000\n\n$ kill %2\n[2] + 18745 terminated nohup sleep 2000\n\n$ jobs\n\nA special signal is SIGKILL since it cannot be captured by the process and it will always terminate it immediately. However, it can have bad side effects such as leaving orphaned children processes.\nYou can learn more about these and other signals here or typing man signal or kill -l.\nWhen using the command line interface you will often want to run more than one thing at once. For instance, you might want to run your editor and your program side by side. Although this can be achieved by opening new terminal windows, using a terminal multiplexer is a more versatile solution.\nTerminal multiplexers like tmux allow you to multiplex terminal windows using panes and tabs so you can interact with multiple shell sessions. Moreover, terminal multiplexers let you detach a current terminal session and reattach at some point later in time. This can make your workflow much better when working with remote machines since it avoids the need to use nohup and similar tricks.\nThe most popular terminal multiplexer these days is tmux. tmux is highly configurable and by using the associated keybindings you can create multiple tabs and panes and quickly navigate through them.\ntmux expects you to know its keybindings, and they all have the form &lt;C-b&gt; x where that means (1) press Ctrl+b, (2) release Ctrl+b, and then (3) press x. tmux has the following hierarchy of objects:\n\nSessions - a session is an independent workspace with one or more windows\n\ntmux starts a new session.\ntmux new -s NAME starts it with that name.\ntmux ls lists the current sessions\nWithin tmux typing &lt;C-b&gt; d detaches the current session\ntmux a attaches the last session. You can use -t flag to specify which\n\nWindows - Equivalent to tabs in editors or browsers, they are visually separate parts of the same session\n\n&lt;C-b&gt; c Creates a new window. To close it you can just terminate the shells doing &lt;C-d&gt;\n&lt;C-b&gt; N Go to the N th window. Note they are numbered\n&lt;C-b&gt; p Goes to the previous window\n&lt;C-b&gt; n Goes to the next window\n&lt;C-b&gt; , Rename the current window\n&lt;C-b&gt; w List current windows\n\nPanes - Like vim splits, panes let you have multiple shells in the same visual display.\n\n&lt;C-b&gt; &quot; Split the current pane horizontally\n&lt;C-b&gt; % Split the current pane vertically\n&lt;C-b&gt; &lt;direction&gt; Move to the pane in the specified direction. Direction here means arrow keys.\n&lt;C-b&gt; z Toggle zoom for the current pane\n&lt;C-b&gt; [ Start scrollback. You can then press &lt;space&gt; to start a selection and &lt;enter&gt; to copy that selection.\n&lt;C-b&gt; &lt;space&gt; Cycle through pane arrangements.\n\nFor further reading, here is a quick tutorial on tmux and this has a more detailed explanation that covers the original screen command. You might also want to familiarize yourself with screen, since it comes installed in most UNIX systems.\nIt can become tiresome typing long commands that involve many flags or verbose options. For this reason, most shells support aliasing. A shell alias is a short form for another command that your shell will replace automatically for you. For instance, an alias in bash has the following structure:\nalias alias_name=&quot;command_to_alias arg1 arg2&quot;\n\nNote that there is no space around the equal sign =, because alias is a shell command that takes a single argument.\nAliases have many convenient features:\n# Make shorthands for common flags\nalias ll=&quot;ls -lh&quot;\n\n# Save a lot of typing for common commands\nalias gs=&quot;git status&quot;\nalias gc=&quot;git commit&quot;\nalias v=&quot;vim&quot;\n\n# Save you from mistyping\nalias sl=ls\n\n# Overwrite existing commands for better defaults\nalias mv=&quot;mv -i&quot; # -i prompts before overwrite\nalias mkdir=&quot;mkdir -p&quot; # -p make parent dirs as needed\nalias df=&quot;df -h&quot; # -h prints human readable format\n\n# Alias can be composed\nalias la=&quot;ls -A&quot;\nalias lla=&quot;la -l&quot;\n\n# To ignore an alias run it prepended with \\\n\\ls\n# Or disable an alias altogether with unalias\nunalias la\n\n# To get an alias definition just call it with alias\nalias ll\n# Will print ll='ls -lh'\n\nNote that aliases do not persist shell sessions by default. To make an alias persistent you need to include it in shell startup files, like .bashrc or .zshrc, which we are going to introduce in the next section.\nMany programs are configured using plain-text files known as dotfiles (because the file names begin with a ., e.g. ~/.vimrc, so that they are hidden in the directory listing ls by default).\nShells are one example of programs configured with such files. On startup, your shell will read many files to load its configuration. Depending on the shell, whether you are starting a login and/or interactive the entire process can be quite complex. Here is an excellent resource on the topic.\nFor bash, editing your .bashrc or .bash_profile will work in most systems. Here you can include commands that you want to run on startup, like the alias we just described or modifications to your PATH environment variable. In fact, many programs will ask you to include a line like export PATH=&quot;$PATH:/path/to/program/bin&quot; in your shell configuration file so their binaries can be found.\nSome other examples of tools that can be configured through dotfiles are:\n\nbash - ~/.bashrc, ~/.bash_profile\ngit - ~/.gitconfig\nvim - ~/.vimrc and the ~/.vim folder\nssh - ~/.ssh/config\ntmux - ~/.tmux.conf\n\nHow should you organize your dotfiles? They should be in their own folder, under version control, and symlinked into place using a script. This has the benefits of:\n\nEasy installation: if you log in to a new machine, applying your customizations will only take a minute.\nPortability: your tools will work the same way everywhere.\nSynchronization: you can update your dotfiles anywhere and keep them all in sync.\nChange tracking: you’re probably going to be maintaining your dotfiles for your entire programming career, and version history is nice to have for long-lived projects.\n\nWhat should you put in your dotfiles? You can learn about your tool’s settings by reading online documentation or man pages. Another great way is to search the internet for blog posts about specific programs, where authors will tell you about their preferred customizations. Yet another way to learn about customizations is to look through other people’s dotfiles: you can find tons of dotfiles repositories on Github — see the most popular one here (we advise you not to blindly copy configurations though). Here is another good resource on the topic.\nAll of the class instructors have their dotfiles publicly accessible on GitHub: Anish, Jon, Jose.\nPortability\nA common pain with dotfiles is that the configurations might not work when working with several machines, e.g. if they have different operating systems or shells. Sometimes you also want some configuration to be applied only in a given machine.\nThere are some tricks for making this easier. If the configuration file supports it, use the equivalent of if-statements to apply machine specific customizations. For example, your shell could have something like:\nif [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then {do_something}; fi\n\n# Check before using shell-specific features\nif [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then {do_something}; fi\n\n# You can also make it machine-specific\nif [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then {do_something}; fi\n\nIf the configuration file supports it, make use of includes. For example, a ~/.gitconfig can have a setting:\n[include]\npath = ~/.gitconfig_local\n\nAnd then on each machine, ~/.gitconfig_local can contain machine-specific settings. You could even track these in a separate repository for machine-specific settings.\nThis idea is also useful if you want different programs to share some configurations. For instance, if you want both bash and zsh to share the same set of aliases you can write them under .aliases and have the following block in both:\n# Test if ~/.aliases exists and source it\nif [ -f ~/.aliases ]; then\nsource ~/.aliases\nfi\n\nIt has become more and more common for programmers to use remote servers in their everyday work. If you need to use remote servers in order to deploy backend software or you need a server with higher computational capabilities, you will end up using a Secure Shell (SSH). As with most tools covered, SSH is highly configurable so it is worth learning about it.\nTo ssh into a server you execute a command as follows\nHere we are trying to ssh as user foo in server bar.mit.edu. The server can be specified with a URL (like bar.mit.edu) or an IP (something like foobar@192.168.1.42). Later we will see that if we modify ssh config file you can access just using something like ssh bar.\nExecuting commands\nAn often overlooked feature of ssh is the ability to run commands directly. ssh foobar@server ls will execute ls in the home folder of foobar. It works with pipes, so ssh foobar@server ls | grep PATTERN will grep locally the remote output of ls and ls | ssh foobar@server grep PATTERN will grep remotely the local output of ls.\nSSH Keys\nKey-based authentication exploits public-key cryptography to prove to the server that the client owns the secret private key without revealing the key. This way you do not need to reenter your password every time. Nevertheless, the private key (often ~/.ssh/id_rsa and more recently ~/.ssh/id_ed25519) is effectively your password, so treat it like so.\nKey generation\nTo generate a pair you can run ssh-keygen.\nssh foo@bar.mit.edu\n\nYou should choose a passphrase, to avoid someone who gets hold of your private key to access authorized servers. Use ssh-agent or gpg-agent so you do not have to type your passphrase every time.\nIf you have ever configured pushing to GitHub using SSH keys, then you have probably done the steps outlined here and have a valid key pair already. To check if you have a passphrase and validate it you can run ssh-keygen -y -f /path/to/key.\nKey based authentication\nssh will look into .ssh/authorized_keys to determine which clients it should let in. To copy a public key over you can use:\nssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519\n\nA simpler solution can be achieved with ssh-copy-id where available:\ncat .ssh/id_ed25519.pub | ssh foobar@remote 'cat &gt;&gt; ~/.ssh/authorized_keys'\n\nCopying files over SSH\nThere are many ways to copy files over ssh:\n\nssh+tee, the simplest is to use ssh command execution and STDIN input by doing cat localfile | ssh remote_server tee serverfile. Recall that tee writes the output from STDIN into a file.\nscp when copying large amounts of files/directories, the secure copy scp command is more convenient since it can easily recurse over paths. The syntax is scp path/to/local_file remote_host:path/to/remote_file\nrsync improves upon scp by detecting identical files in local and remote, and preventing copying them again. It also provides more fine grained control over symlinks, permissions and has extra features like the --partial flag that can resume from a previously interrupted copy. rsync has a similar syntax to scp.\n\nPort Forwarding\nIn many scenarios you will run into software that listens to specific ports in the machine. When this happens in your local machine you can type localhost:PORT or 127.0.0.1:PORT, but what do you do with a remote server that does not have its ports directly available through the network/internet?.\nThis is called port forwarding and it comes in two flavors: Local Port Forwarding and Remote Port Forwarding (see the pictures for more details, credit of the pictures from this StackOverflow post).\nLocal Port Forwarding\n\nRemote Port Forwarding\n\nThe most common scenario is local port forwarding, where a service in the remote machine listens in a port and you want to link a port in your local machine to forward to the remote port. For example, if we execute jupyter notebook in the remote server that listens to the port 8888. Thus, to forward that to the local port 9999, we would do ssh -L 9999:localhost:8888 foobar@remote_server and then navigate to locahost:9999 in our local machine.\nSSH Configuration\nWe have covered many many arguments that we can pass. A tempting alternative is to create shell aliases that look like\nssh-copy-id -i .ssh/id_ed25519 foobar@remote\n\nHowever, there is a better alternative using ~/.ssh/config.\nalias my_server=&quot;ssh -i ~/.id_ed25519 --port 2222 -L 9999:localhost:8888 foobar@remote_server\n\nAn additional advantage of using the ~/.ssh/config file over aliases is that other programs like scp, rsync, mosh, &amp;c are able to read it as well and convert the settings into the corresponding flags.\nNote that the ~/.ssh/config file can be considered a dotfile, and in general it is fine for it to be included with the rest of your dotfiles. However, if you make it public, think about the information that you are potentially providing strangers on the internet: addresses of your servers, users, open ports, &amp;c. This may facilitate some types of attacks so be thoughtful about sharing your SSH configuration.\nServer side configuration is usually specified in /etc/ssh/sshd_config. Here you can make changes like disabling password authentication, changing ssh ports, enabling X11 forwarding, &amp;c. You can specify config settings on a per user basis.\nMiscellaneous\nA common pain when connecting to a remote server are disconnections due to your computer shutting down, going to sleep, or changing networks. Moreover if one has a connection with significant lag using ssh can become quite frustrating. Mosh, the mobile shell, improves upon ssh, allowing roaming connections, intermittent connectivity and providing intelligent local echo.\nSometimes it is convenient to mount a remote folder. sshfs can mount a folder on a remote server locally, and then you can use a local editor.\nDuring shell tool and scripting we covered the bash shell because it is by far the most ubiquitous shell and most systems have it as the default option. Nevertheless, it is not the only option.\nFor example, the zsh shell is a superset of bash and provides many convenient features out of the box such as:\n\nSmarter globbing, **\nInline globbing/wildcard expansion\nSpelling correction\nBetter tab completion/selection\nPath expansion (cd /u/lo/b will expand as /usr/local/bin)\n\nFrameworks can improve your shell as well. Some popular general frameworks are prezto or oh-my-zsh, and smaller ones that focus on specific features such as zsh-syntax-highlighting or zsh-history-substring-search. Shells like fish include many of these user-friendly features by default. Some of these features include:\n\nRight prompt\nCommand syntax highlighting\nHistory substring search\nmanpage based flag completions\nSmarter autocompletion\nPrompt themes\n\nOne thing to note when using these frameworks is that they may slow down your shell, especially if the code they run is not properly optimized or it is too much code. You can always profile it and disable the features that you do not use often or value over speed.\nAlong with customizing your shell, it is worth spending some time figuring out your choice of terminal emulator and its settings. There are many many terminal emulators out there (here is a comparison).\nSince you might be spending hundreds to thousands of hours in your terminal it pays off to look into its settings. Some of the aspects that you may want to modify in your terminal include:\n\nFont choice\nColor Scheme\nKeyboard shortcuts\nTab/Pane support\nScrollback configuration\nPerformance (some newer terminals like Alacritty or kitty offer GPU acceleration).\n\nJob control\n\nFrom what we have seen, we can use some ps aux | grep commands to get our jobs’ pids and then kill them, but there are better ways to do it. Start a sleep 10000 job in a terminal, background it with Ctrl-Z and continue its execution with bg. Now use pgrep to find its pid and pkill to kill it without ever typing the pid itself. (Hint: use the -af flags).\n\nSay you don’t want to start a process until another completes. How would you go about it? In this exercise, our limiting process will always be sleep 60 &amp;. One way to achieve this is to use the wait command. Try launching the sleep command and having an ls wait until the background process finishes.\nHowever, this strategy will fail if we start in a different bash session, since wait only works for child processes. One feature we did not discuss in the notes is that the kill command’s exit status will be zero on success and nonzero otherwise. kill -0 does not send a signal but will give a nonzero exit status if the process does not exist. Write a bash function called pidwait that takes a pid and waits until the given process completes. You should use sleep to avoid wasting CPU unnecessarily.\n\nTerminal multiplexer\n\nFollow this tmux tutorial and then learn how to do some basic customizations following these steps.\n\nAliases\n\nCreate an alias dc that resolves to cd for when you type it wrongly.\n\nRun history | awk '{$1=&quot;&quot;;print substr($0,2)}' | sort | uniq -c | sort -n | tail -n 10 to get your top 10 most used commands and consider writing shorter aliases for them. Note: this works for Bash; if you’re using ZSH, use history 1 instead of just history.\n\nDotfiles\nLet’s get you up to speed with dotfiles.\n\nCreate a folder for your dotfiles and set up version control.\nAdd a configuration for at least one program, e.g. your shell, with some customization (to start off, it can be something as simple as customizing your shell prompt by setting $PS1).\nSet up a method to install your dotfiles quickly (and without manual effort) on a new machine. This can be as simple as a shell script that calls ln -s for each file, or you could use a specialized utility.\nTest your installation script on a fresh virtual machine.\nMigrate all of your current tool configurations to your dotfiles repository.\nPublish your dotfiles on GitHub.\n\nRemote Machines\nInstall a Linux virtual machine (or use an already existing one) for this exercise. If you are not familiar with virtual machines check out this tutorial for installing one.\n\nGo to ~/.ssh/ and check if you have a pair of SSH keys there. If not, generate them with ssh-keygen -o -a 100 -t ed25519. It is recommended that you use a password and use ssh-agent , more info here.\n\nEdit .ssh/config to have an entry as follows\nHost vm\nUser foobar\nHostName 172.16.174.141\nPort 2222\nIdentityFile ~/.ssh/id_ed25519\nLocalForward 9999 localhost:8888\n# Configs can also take wildcards\nHost *.mit.edu\nUser foobaz\n\nUse ssh-copy-id vm to copy your ssh key to the server.\n\nStart a webserver in your VM by executing python -m http.server 8888. Access the VM webserver by navigating to http://localhost:9999 in your machine.\n\nEdit your SSH server config by doing sudo vim /etc/ssh/sshd_config and disable password authentication by editing the value of PasswordAuthentication. Disable root login by editing the value of PermitRootLogin. Restart the ssh service with sudo service sshd restart. Try sshing in again.\n\n(Challenge) Install mosh in the VM and establish a connection. Then disconnect the network adapter of the server/VM. Can mosh properly recover from it?\n\n(Challenge) Look into what the -N and -f flags do in ssh and figure out a command to achieve background port forwarding.\n\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890",
		"tags": ["Z", "note","gardenEntry"]
}
]